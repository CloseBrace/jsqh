<html>
  <body>
    <div>
      <p>Make sure to open your JavaScript console!</p>
    </div>
  </body>
<script>

const movieList = ['Alien', 'Aliens', 'Alien 3', 'Alien Resurrection', 'Prometheus', 'Alien Covenant'];

// NOTE: the code at the very bottom of this example actually executes first

// Here are two asynchronous functions that resolves a promise (see tutorial 14)
const getMovies = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(movieList);
    }, 2000);
  });
};
const storeMovies = (movies) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      // Simulating a "successfully stored to the database" response
      resolve({
        status: 200,
        message: 'Success',
      });
    }, 2000);
  });
}

// You can use .then to access the resolve value
getMovies().then((movies) => {
  console.log(movies);
  console.log('------------');
});

// But you when you start wrapping functions, the nesting gets annoying:
const getAndStoreMovies = () => {
  getMovies().then((movies) => {
    storeMovies(movies).then((resp) => {
      if (resp.status === 200) {
        console.log('Succeeded (.then)');
        console.log('------------');
        return;
      }
      console.log('Failed (.then)');
      console.log('------------');
      return;
    });
  });
}
getAndStoreMovies();

// Async / await lets us wait for values to populate before proceeding!
// (remove the "await"s for fun errors as the function executes before the promises resolve)
const storeReversedMovies = async () => {
  const movies = await getMovies();
  const reversedMovies = movies.reverse();
  const response = await storeMovies(reversedMovies);
  if (response.status === 200) {
    console.log(reversedMovies); // our reversed array
    console.log('------------');
    return
  }
  console.log('Failed (async / await)');
  console.log('------------');
}
storeReversedMovies();

// async / await only works with promises. It won't work with a regular async function
const noPromiseTimer = (callback) => {
  setTimeout(() => {
    const ridleyScottMovies = [movieList[0], movieList[4], movieList[5]];
    callback(ridleyScottMovies);
  }, 5000);
}
const getScottMovies = async () => {
  const list = await noPromiseTimer((movies) => {
    return movies;
  });
  return list;
}
const scottMovies = getScottMovies();
console.log(scottMovies); // instantly returns a promise generated by "await" but which is never resolved in "noPromiseTimer"
console.log('------------');

// You can also await on the variables instead of the function
// ... if you don't need the value from the first await for the second one
const takeTooLongToUpperCase = (str) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(str.toUpperCase());
    }, 5000);
  });
}

const upperCaseMovies = async (list) => {
  const item0 = takeTooLongToUpperCase(list[0]);
  const item1 = takeTooLongToUpperCase(list[1]);
  return [await item0, await item1];
}

// This will log the new array in just 5 seconds, instead of 10, since the two function calls run simultaneously
upperCaseMovies(movieList).then((newList) =>{
  console.log(newList); // ['ALIEN', 'ALIENS'];
});

</script>
</html>